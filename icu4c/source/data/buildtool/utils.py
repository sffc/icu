# Copyright (C) 2018 and later: Unicode, Inc. and others.
# License & terms of use: http://www.unicode.org/copyright.html

from . import *


def dir_for(file):
    if isinstance(file, InFile):
        return "{IN_DIR}"
    if isinstance(file, TmpFile):
        return "{TMP_DIR}"
    if isinstance(file, OutFile):
        return "{OUT_DIR}"
    if isinstance(file, PkgFile):
        return "{PKG_DIR}"
    assert False


def concat_dicts(*dicts):
    # There is not a super great way to do this in Python:
    new_dict = {}
    for dict in dicts:
        new_dict.update(dict)
    return new_dict


def repeated_execution_request_looper(request):
    # dictionary of lists to list of dictionaries:
    ld = [
        dict(zip(request.repeat_with, t))
        for t in zip(*request.repeat_with.values())
    ]
    if not ld:
        # No special options given in repeat_with
        ld = [{} for _ in range(len(request.input_files))]
    return zip(ld, request.input_files, request.output_files)


def format_single_request_command(request, cmd_template, common_vars):
    return cmd_template.format(
        ARGS = request.args.format(
            INPUT_FILES = [file.filename for file in request.input_files],
            OUTPUT_FILES = [file.filename for file in request.output_files],
            **concat_dicts(common_vars, request.format_with)
        )
    )


def format_repeated_request_command(request, cmd_template, loop_vars, common_vars):
    (iter_vars, input_file, output_file) = loop_vars
    return cmd_template.format(
        ARGS = request.args.format(
            INPUT_FILE = input_file.filename,
            OUTPUT_FILE = output_file.filename,
            **concat_dicts(common_vars, request.format_with, iter_vars)
        )
    )


def flatten(request, max_parallel):
    """Flatten a RepeatedOrSingleExecutionRequest

    Becomes either a SingleExecutionRequest or a RepeatedExecutionRequest.
    """
    if max_parallel:
        return RepeatedExecutionRequest(
            name = request.name,
            dep_files = request.dep_files,
            input_files = request.input_files,
            output_files = request.output_files,
            tool = request.tool,
            args = request.args,
            format_with = request.format_with,
            repeat_with = request.repeat_with
        )
    else:
        return SingleExecutionRequest(
            name = request.name,
            input_files = request.dep_files + request.input_files,
            output_files = request.output_files,
            tool = request.tool,
            args = request.args,
            format_with = concat_dicts(request.format_with, request.flatten_with)
        )


def generate_index_file(locales, cldr_version, common_vars):
    formatted_version = "    CLDRVersion { \"%s\" }\n" % cldr_version if cldr_version else ""
    formatted_locales = "\n".join(["        %s {\"\"}" % v for v in locales])
    # TODO: CLDRVersion is required only in the base file
    return ("// Warning this file is automatically generated\n"
            "{INDEX_NAME}:table(nofallback) {{\n"
            "{FORMATTED_VERSION}"
            "    InstalledLocales {{\n"
            "{FORMATTED_LOCALES}\n"
            "    }}\n"
            "}}").format(
                FORMATTED_VERSION = formatted_version,
                FORMATTED_LOCALES = formatted_locales,
                **common_vars
            )


def get_all_output_files(requests, include_tmp=False):
    files = []
    for request in requests:
        if isinstance(request, SingleExecutionRequest):
            files += request.output_files
        elif isinstance(request, RepeatedExecutionRequest):
            files += request.output_files
        elif isinstance(request, RepeatedOrSingleExecutionRequest):
            files += request.output_files
        elif isinstance(request, PrintFileRequest):
            files += [request.output_file]
        elif isinstance(request, CopyRequest):
            files += [request.output_file]
        elif isinstance(request, VariableRequest):
            pass
        else:
            assert False

    # Filter out all files but those in OUT_DIR if necessary.
    # It is also easy to filter for uniqueness; do it right now and return.
    if not include_tmp:
        files = (file for file in files if isinstance(file, OutFile))
        return list(set(files))

    # Filter for unique values.  NOTE: Cannot use set() because we need to accept same filename as
    # OutFile and TmpFile as different, and by default they evaluate as equal.
    return [f for _, f in set((type(f), f) for f in files)]
